<!DOCTYPE html>
<html>

<head>
   <meta charset='utf-8'>
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="styles.css">
   <script src="http://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
   <script src="script.js"></script>
<title> Prima pagina</title>
</head>

<div class="header">
  <img src="info1.jpg" alt="Italian Trulli" style="max-width: 100%">
</div>
<div id='cssmenu'>
<ul>
 <li><a href='index.html'>Main page</a></li>
   <li class='active'><a href='#'>Algoritmul lui Roy-Floyd</a>
   <li class='active'><a href='#'>Algoritmul lui Dijkstra</a>
      
     

   <li class='active'><a href='#'>Algoritmul lui Prim</a>
   <li class='active'><a href='#'>Algoritmul lui Kruskal</a>
  
</ul>
</div>


<head>
<style>
body  {
  background-image: url("back2.jpg");
  background-color: #cccccc;
   background-size: cover;
}
</style>
</head>
<pre style=" background: rgba( 0, 176, 153, 0.5) "><h1> Algoritmul lui Roy-Floyd</h1></pre>


<style>
table td, tr{
  border:2px solid black;
}
.nobrd {
  border: 0;
}
</style>
<body>

<table style="width:100%;" class="nobrd">
  <tr>
   
    <td>Algoritmul Roy-Floyd este folosit in diverse domenii des întalnite, de la controlul avioanelor de pe un anumit aeroport pana la jocuri informatice, rolul principal fiind acela de găsire a drumului de cost minim între un obiect principal si o ținta anume.
      <br>
      <br>
      Problemă:
Se dă un graf orientat ponderat cu n noduri și m arce – în care fiecare arc are asociat un cost, număr natural strict pozitiv. Folosind algoritmul Roy-Floyd, construiți matricea costurilor minime, a[i][j] fiind costul minim al unui drum de la i la j, dacă există un asemenea drum, sau -1 în caz contrar.

</td>
<td style="max-width: fit-content;"> <img src="graf4.jpg"  width="400"; height="200"; align=center> </td>
  </tr>
</table>
</body>
<br>

<body>

<table style="width:100%">
  <tr>
    <td> <pre> #include bits/stdc++.h 
using namespace std;
ifstream cin("roy-floyd.in");
ofstream cout("roy-floyd.out");
const int Inf = 0x3f3f3f3f;
int n, m, x, y, w, c[101][101];
void Floyd_Warshall()
{
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                if (i != j && c[i][j] > c[i][k] + c[k][j])
                    c[i][j] = c[i][k] + c[k][j];
}
int main()
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; ++i)
        for (int j = 1 ; j <= n ; ++j)
            if (i != j)
                c[i][j] = Inf;
    for(int i = 1 ; i <= m ; i++)
    {
        cin >> x >> y >> w;
        c[x][y] = w;
    }
    Floyd_Warshall();
    for (int i = 1 ; i <= n ; ++i)
    {
        for (int j = 1 ; j <= n ; ++j)
            if(c[i][j] != Inf)
                cout << c[i][j] << ' ';
            else
                cout << "-1 ";
        cout << '\n';
    }
}
</pre>
    </td>
  
  </tr>
</table>
<br>
<pre style=" background: rgba( 0, 176, 153, 0.5) "><h1> Algoritmul lui Dijkstra</h1></pre>

<br>
<body>

<table style="width:100%">
  <tr>
   
    <td><pre style="max-width:60%">Algoritmul lui Dijkstra determină pentru un nod dat într-un graf orientat cu costuri costurileminime ale drumurilor 
      care au acel nod ca extremitate inițială.
Mai precis, pentru un nod s – sursă, algoritmul determină pentru orice nod x costul minim al unui drum de la s la x.
Strategia algoritmului lui Dijkstra este una de tip Greedy
Algoritm:
1.  Se creează o listă cu distanțe, o listă cu nodul anterior, o listă cu nodurile vizitate și un nod curent.
2.  Toate valorile din lista cu distanțe sunt inițializate cu o valoare infinită, cu excepția nodului de start, care este
 setat cu 0.
3.  Toate valorile din lista cu nodurile vizitate sunt setate cu fals.
4.  Toate valorile din lista cu nodurile anterioare sunt inițializate cu -1.
5.  Nodul de start este setat ca nodul curent.
6.  Se marchează ca vizitat nodul curent.
7.  Se actualizează distanțele, pe baza nodurilor care pot fi vizitate imediat din nodul curent.
8.  Se actualizează nodul curent la nodul nevizitat care poate fi vizitat prin calea cea mai scurtă de la nodul de start.
9.  Se repetă (de la punctul 6) până când toate nodurile sunt vizitate.

Aplicarea algoritmului lui Djkstra pentru graful de mai jos, unde s=1;

<img src="graf5.jpg" style width="300"; height="200">
</pre>

</td>
<td> <pre> #define INFINIT 1000000000
...
//nodul sursa este s
...
for(i =1 ; i <= n ; i ++ )
{
  f[i] = 0;
  d[i] = a[s][i];
}

f[s] = 1, d[s] = 0;
d[0] = INFINIT; // pentru determinarea nodului cu costul minim
for(int k = 1 ; k < n ; ++k)
{
  int pmax = 0;
  for(i = 1 ; i <= n ; ++i)
    if(f[i] == 0 && d[i] < d[pmax])
      pmax = i;

  if(pmax > -1)
  {     f[pmax] = 1;
    for(i = 1; i <= n ; ++i)
      if(f[i] == 0 && d[i] > d[pmax] + a[pmax][i])
        d[i] = d[pmax] + a[pmax][i]; }
}


</pre></td>
  </tr>
</table>
</body>
<br>
<pre style=" background: rgba( 0, 176, 153, 0.5) "><h1> Algoritmul lui Prim</h1></pre>
<br>
<body>

<table style="width:100%">
  <tr>
   
    <td><pre style="max-width:100%; margin-bottom: 650px">Algoritmul lui Prim permite determinarea unui arbore parțial de cost minim (APM) într-un graf ponderat 
      cu N noduri.

Descrierea algoritmului:
Determinarea APM-ului se face astfel:
• se stabilește un nod de plecare; acesta va fi rădăcina arborelui, care se va crea pas cu pas, prin adăugarea de
 noi noduri;
• în mod repetat:
o se alege un nod neadăugat încă în arborele curent pentru care muchia dintre el și un nod din arbore
 are cost minim;
o se adăugă nodul în arbore;
• când nu se mai poate face alegerea unui asemenea nod, fie au fost adăugate toate nodurile, 
fie graful nu este conex și au fost adăugate în arbore toate nodurile din componenta conexă a nodul inițial;
• dacă graful nu este conex, continuăm cu următoarea componentă conexă.
Algoritmul poate fi implementat în mai multe moduri, cu complexități diferite.
 Problema:
Se dă un graf neorientat ponderat conex cu n vârfuri și m muchii – în care fiecare muchie are 
asociat un cost, număr natural strict pozitiv. Folosind algoritmul lui Prim, determinați
 un arbore parțial de cost minim, cu rădăcina în vârful 1.



</pre>

</td>
<td> <pre>#include <iostream>
#include <fstream>
#define INFINIT 1000000000
using namespace std;

ifstream fin("prim.in");
ofstream fout("prim.out");

int n , a[105][105], v[105], d[105], t[105];

int main()
{
    int i , j , c , m;
    fin >> n >> m;
    
    for(i =1 ; i <= n ; ++i){
        for(j = 1 ; j <= n ; ++j)
            a[i][j] = INFINIT;
        a[i][i] = 0;
    }
    
    while( m )
    {
        fin >> i >> j >> c;
        a[j][i] = a[i][j] = c;
        m --;
    }
    
    for(i =1 ; i <= n ; i ++ )
    {
        v[i] = 0;
        d[i] = a[1][i];
        t[i] = 1;
    }
    v[1] = 1; // vectorul de vizitati
    t[1] = 0; //vectorul de tati
    d[1] = 0; // vectorul cu costurile 
    d[0] = INFINIT;
    for(int k = 1 ; k < n ; ++k)
    {
        int pmax = 0;
        // alegem un varful nevizitat care se 
        leaga de arborele curent cu cost minim
        for(i = 1 ; i <= n ; ++i)
            if(v[i] == 0 && d[i] < d[pmax])
                pmax = i;
        if(pmax > -1)
        {
            v[pmax] = 1;
            // verificam daca varful adaugat in arbore nu
             imbunatateste costurile de legare la arbore a
              varfurilor inca nevizitate
            for(i = 1; i <= n ; ++i)
                if(v[i] == 0 && d[i] > a[pmax][i])
                    d[i] = a[pmax][i], t[i] = pmax;
        }
    }
    int S = 0;
    for(i = 1 ; i <= n ; ++i)
        S += d[i];  
    fout << S << endl;
    for(i = 1 ; i <= n ; ++i)
        fout << t[i] << " ";
    
    return 0;
}

</pre></td>
  </tr>
</table>
</body>
<br>
<pre style=" background: rgba( 0, 176, 153, 0.5) "><h1> Algoritmul lui Kruskal</h1></pre>
<br>
<body>

<table style="width:100%">
  <tr>
   
    <td><pre style="max-width:100%; margin-bottom: 950px">    Algoritmul lui Kruskal permite determinarea unui arbore parțial de cost minim (APM) într-un
graf ponderat cu N noduri.

    Pentru a determina APM-ul se pleacă de la o pădure formată din N subarbori. Fiecare nod al grafului
reprezintă inițial un subarbore. Aceștia vor fi reuniți succesiv prin muchii, până când se obține un
singur arbore (dacă graful este conex) sau până când acest lucru nu mai este posibil (dacă graful nu este
conex).
    Algoritmul este:
  -se ordonează muchiile grafului crescător după cost;
  -se analizează pe rând muchiile grafului, în ordinea crescătoare a costurilor;
  -pentru fiecare muchie analizată:
    o dacă extremitățile muchiei fac parte din același subarbore, muchia se ignoră
    o dacă extremitățile muchiei fac parte din subarbori diferiți, aceștia se vor reuni, iar
muchia respectivă face parte din APM.



</pre>

</td>
<td> <pre style="max-width:100%; margin-bottom: 650px">struct muchie
{
    int i,j,cost;
};

int n , m , t[101];

muchie x[5000];

int main()
{
    cin >> n >> m;

    for(int i = 0 ; i < m ; ++i)
        cin >> x[i].i >> x[i].j >> x[i].cost;

//sortare tablou x[] după campul cost
// ... de completat

//initializare reprezentanti
    for(int i =1 ; i <= n ; ++i)
        t[i] = i;
//determinare APM
    int S = 0, cnt = 0;
    for(int i = 0 ; i < m && cnt < n ; i ++)



        if(t[x[i].i] != t[x[i].j]) // extremitatile fac
         parte din subrabori diferiti
        {
            S += x[i].cost;
//reunim subarborii
            int ai = t[x[i].i], aj = t[x[i].j];
            for(int j =1 ; j <= n ; ++j)
                if(t[j] == aj)
                    t[j] = ai;
        }
    cout << S << "\n";
    return 0;
}
</pre></td>
  </tr>
</table>
</body>
</html>


